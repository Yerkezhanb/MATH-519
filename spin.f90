module spinStuff
  use globvars
  implicit none

  ! 'primitive' -- a simple spin function with given value of S_z
  ! examples: aaa, aba, aaabab

  ! spin function -- a linear combination of primitives
  ! we usually want it to be an eigenfunction of S^2
  ! example: -aab-baa+2aba
  ! it is not unique in principle, and should be generated by the
  ! spin Young operator, which should be built from transposed spatial Young table
  ! spin function is stored as an array of coefficients of corresponding primitives

  ! all the unique primitives should be generated (the number of them is C_n^k, where k is a number of b's)
  ! ^2Li case:
  ! aab
  ! aba
  ! baa

  !integer, parameter :: dprec = kind(1.d0)
  real(kind = dprec), parameter :: localEps = 1.d-14 ! numerical zero
  integer, parameter :: maxLen = 255 ! fixed length of any string generated in the module

contains

  subroutine getSpinOperatorsMeanValues(n, nFactorial, spatialYoung, positronPosition, numberOfSpinFunctions, &
    permutationMatrices, parities, spinFreeME, SiSjMe)
    implicit none

    integer, intent(in) :: n, nFactorial
    character(len = *), intent(in) :: spatialYoung

    integer, intent(out) :: positronPosition, numberOfSpinFunctions
    integer, dimension(n, n, nFactorial), intent(out) :: permutationMatrices
    integer, dimension(n), intent(out) :: parities

    ! mean values of some spin operators
    real(kind = dprec), dimension(nFactorial), intent(out) :: spinFreeME
    real(kind = dprec), dimension(n, n, 2, nFactorial), intent(out) :: SiSjME

    ! local variables
    integer :: Cnk, ptr, NumYTerms
    integer :: i, j, youngLen, k, kFactorial, found, numberOfPrimitives
    integer :: numberOfAs, p, pos, io, SeDoubled
    integer, dimension(:), allocatable :: particles

    integer, dimension(:, :, :, :), allocatable :: pairPermutations
    integer, dimension(:, :), allocatable :: primitives
    integer, dimension(:), allocatable :: primitiveA, YCoeff
    integer, dimension(:, :, :), allocatable :: YMatr

    integer, dimension(:), allocatable :: spinFunction, intSpinfunctionA, intSpinfunctionB
    integer, dimension(:, :), allocatable :: spinFunctionsArray
    real(kind = dprec), dimension(:), allocatable :: tmpSpinFunctionA, tmpSpinFunctionB, tmpSpinFunctionC

    character (len = maxLen) :: myFmt
    character(len = maxLen) :: spinFunctionString
    real(kind = dprec) :: test, norm1, norm2
    real(kind = dprec), dimension(:, :), allocatable :: finalSpinFunctions

    logical :: success


    allocate(particles(n))
    youngLen = len(spatialYoung)

    ! based on Young operator string we want
    ! to understand where is the positron
    ! (its number is not presented in the Young string)

    particles = 0
    do i = 1, youngLen
      if (spatialYoung(i:i) == 'P') then
        read(spatialYoung(i + 1: i + 1), *) j
        particles(j) = particles(j) + 1
        read(spatialYoung(i + 2: i + 2), *) j
        particles(j) = particles(j) + 1
      endif
    enddo

    positronPosition = -1
    do i = 1, n
      if (particles(i) == 0) then
        positronPosition = i
      endif
    enddo

    ! now we should generate our spin function with k '1's (spin up)
    ! we should get the value of k from the spatial Young operator
    ! k = n - b, where b is the number of electrons in the 2nd column
    ! it can be calculated as a number of '+' signs before the 'Pij)'
    ! BUT NOT ALWAYS (smth weird can appear in A part of Young operator)
    ! note that we assume S = S_z

    if (positronPosition > 0) then
      numberOfAs = n - 1
    else
      numberOfAs = n
    endif

    do i = 1, youngLen
      if (spatialYoung(i:i) == 'P') then
        if ((spatialYoung(i - 1:i - 1) == '+') .and. (spatialYoung(i + 3:i + 3) == ')')) numberOfAs = numberOfAs - 1
      endif
    enddo
    
    if (positronPosition > 0) then
      SeDoubled = 2 * numberOfAs - n + 1
    else
      SeDoubled = 2 * numberOfAs - n
    endif

    if (positronPosition > 0 .and. SeDoubled > 0) then
      numberOfSpinFunctions = 2
    else
      numberOfSpinFunctions = 1
    endif

    ! if we only have electrons, we generate spin function chi:
    ! S^2 chi_{S, S} = S (S + 1) chi_{S, S}
    ! S_z chi_{S, S} = S chi_{S, S}
    ! if we have a positron, then we will need either
    ! chi_{S, S} chi_{1/2, 1/2}, chi_{S, S} chi_{1/2, -1/2}, and chi_{S, S - 1} chi_{1/2, 1/2}
    ! to construct total wavefunction
    ! or chi_{S, S} chi_{1/2, 1/2} for a singlet electronic state

    ! we will need a complete "dictionary" of primitives
    numberOfPrimitives = 0

    if (positronPosition < 0) then ! electrons only

      kFactorial = 1
      do i = 1, numberOfAs
        kFactorial = kFactorial * i
      enddo

      ! we generate an array of all the possible permutations of a given string
      ! of k '1's and n - k '0's (the dimension of the array is C(n, k))
      Cnk = 1
      do i = n - numberOfAs + 1, n
        Cnk = Cnk * i
      enddo
      Cnk = Cnk / kFactorial

      numberOfPrimitives = Cnk
    else
      do p = 0, 1

        kFactorial = 1

        do i = 1, numberOfAs + p
          kFactorial = kFactorial * i
        enddo

        Cnk = 1
        do i = n - (numberOfAs + p) + 1, n
          Cnk = Cnk * i
        enddo

        Cnk = Cnk / kFactorial

        numberOfPrimitives = numberOfPrimitives + Cnk

      enddo
    endif

    allocate(spinFunctionsArray(numberOfPrimitives, 3))
    spinFunctionsArray = 0

    allocate(primitives(n, numberOfPrimitives))
    primitives = 0

    allocate(spinFunction(numberOfPrimitives))
    spinFunction = 0
    allocate(primitiveA(n))

    allocate(Ycoeff(nFactorial))
    allocate(YMatr(n, n, nFactorial))
    allocate(intSpinfunctionA(numberOfPrimitives), intSpinfunctionB(numberOfPrimitives))

    call generatePermutationMatrices(permutationMatrices, n, nFactorial, parities)

    call generateSpinYoungFromSpatialString(spatialYoung, n, nFactorial, NumYTerms, YCoeff, YMatr)

    if (positronPosition < 0) then ! electrons only

      ! fill in the 1st primitive string
      do i = 1, numberOfAs
        primitives(i, 1) = 1
      enddo

      ! using the permutation matrices we generate all the unique sequences
      ptr = 2
      do i = 2, nFactorial

        if (ptr > numberOfPrimitives) then ! already found everything
          exit
        endif

        call permute(permutationMatrices(:, :, i), primitives(:, 1), primitiveA, n)

        ! check whether we have the string already
        found = 0
        do k = 1, ptr - 1
          if (primitivesScalarProduct(primitives(:, k), primitiveA, n) == 1) then
            found = 1
            exit
          endif
        enddo

        if (found == 0) then
          primitives(:, ptr) = primitiveA
          ptr = ptr + 1
        endif


      enddo

    else

      ! fill in the primitive string with numberOfAs + 1 'a's
      do i = 1, numberOfAs + 1
        primitives(i, 1) = 1
      enddo

      ! using the permutation matrices we generate all the unique sequences
      ptr = 2
      do i = 2, nFactorial

        call permute(permutationMatrices(:, :, i), primitives(:, 1), primitiveA, n)
        !write(*, myFmt) (primitiveA(j), j = 1, n)

        ! check whether we have the string already
        found = 0
        do k = 1, ptr - 1
          if (primitivesScalarProduct(primitives(:, k), primitiveA, n) == 1) then
            found = 1
            exit
          endif
        enddo

        if (found == 0) then
          primitives(:, ptr) = primitiveA
          ptr = ptr + 1
        endif

      enddo

      ! fill in the primitive string with numberOfAs 'a's
      pos = ptr
      do i = 1, numberOfAs
        primitives(i, pos) = 1
      enddo
      ptr = ptr + 1

      spinFunction = 0
      ! using the permutation matrices we generate all the unique sequences
      do i = 2, nFactorial

        call permute(permutationMatrices(:, :, i), primitives(:, pos), primitiveA, n)

        ! check whether we have the string already
        found = 0
        do k = pos, ptr - 1
          if (primitivesScalarProduct(primitives(:, k), primitiveA, n) == 1) then
            found = 1
            exit
          endif
        enddo

        if (found == 0) then
          primitives(:, ptr) = primitiveA
          ptr = ptr + 1
        endif

      enddo

    endif

    ! write(myFmt, '("(", i0, "(i3))")') n
    ! do i = 1, Cnk
    !   write(*, myFmt) (primitives(j, i), j = 1, n)
    ! enddo


    ! at this point we have a library of any possible primitives
    ! we build and store spin function as an array of coefficients for each
    ! term from library
    ! i.e. {a_i} -> sum_i a_i string_i

    ! we try the primitives one by one until the result of Y (..)
    ! is non-zero
    success = .false.
    j = 1
    do while (.not. success)

      if (j > numberOfPrimitives) stop "unable to build the spin function"

      if (positronPosition > 0) then ! 1st function for positronic systems corresponds to positron spin up
        do while (primitives(positronPosition, j) == 0) 
          j = j + 1 ! skip the primitive number j
        enddo
      endif

      spinFunction(j) = 1
      success = .true.      

      ! call showSpinFunction(spinFunction, primitives, n, numberOfPrimitives, spinFunctionString)
      ! write(*, '(a)') trim(adjustl(spinFunctionString))
      ! print *, '====================================='

      ! act with Young operator on our function
      intSpinfunctionA = 0
      do i = 1, NumYTerms

        intSpinfunctionB = 0
        call permuteSpinFunction(primitives, spinFunction, intSpinfunctionB, YMatr(:, :, i), n, numberOfPrimitives)
        intSpinfunctionA = intSpinfunctionA + YCoeff(i) * intSpinfunctionB

      enddo
      spinFunction = intSpinfunctionA

      if (all(spinFunction(1 : numberOfPrimitives) == 0)) success = .false.
      j = j + 1 

    enddo

    call beautifySpinFunction(spinFunction, numberOfPrimitives)
    spinFunctionsArray(:, 1) = spinFunction

    ! call showSpinFunction(spinFunction, primitives, n, numberOfPrimitives, spinFunctionString)
    ! write(*, '(a)') trim(adjustl(spinFunctionString))
    ! print *, '====================================='


    ! spinFunctionsArray(:, 1) = chi_{S, S} chi_{1/2, 1/2}
    ! spinFunctionsArray(:, 2) = chi_{S, S} chi_{1/2, -1/2}
    ! spinFunctionsArray(:, 3) = chi_{S, S - 1} chi_{1/2, 1/2}

    if (numberOfSpinFunctions == 2) then
      intSpinfunctionA = spinFunctionsArray(:, 1)
      
      ! chi_{S, S} chi_{1/2, -1/2} = S^{positron}_{-} chi_{S, S} chi_{1/2, 1/2}
      call actOnSpinFunctionWithSMinusi(primitives, intSpinfunctionA, positronPosition, n, numberOfPrimitives)
      call beautifySpinFunction(spinFunction, numberOfPrimitives)
      spinFunctionsArray(:, 2) = intSpinfunctionA

      ! call showSpinFunction(intSpinfunctionA, primitives, n, numberOfPrimitives, spinFunctionString)
      ! write(*, '(a)') trim(adjustl(spinFunctionString))
      ! print *, '====================================='
      
      ! chi_{S, S - 1} chi_{1/2, 1/2} = S^{electron}_{-} chi_{S, S} chi_{1/2, 1/2}
      intSpinfunctionB = 0
      do i = 1, n
        if (i == positronPosition) cycle

        intSpinfunctionA = spinFunctionsArray(:, 1)
        call actOnSpinFunctionWithSMinusi(primitives, intSpinfunctionA, i, n, numberOfPrimitives)

        intSpinfunctionB = intSpinfunctionB + intSpinfunctionA
      enddo

      call beautifySpinFunction(intSpinfunctionB, numberOfPrimitives)
      spinFunctionsArray(:, 3) = intSpinfunctionB

      ! call showSpinFunction(intSpinfunctionB, primitives, n, numberOfPrimitives, spinFunctionString)
      ! write(*, '(a)') trim(adjustl(spinFunctionString))
      ! print *, '====================================='
    endif


    allocate(finalSpinFunctions(numberOfPrimitives, 2))
    finalSpinFunctions = ZERO
    ! in case wo only have electrons:
    ! finalSpinFunctions(:, 1) = chi_{S, S}
    ! finalSpinFunctions(:, 2) = 0
    ! for electrons and a positron:
    ! finalSpinFunctions(:, 1) = chi_{S + 1/2, S + 1/2} ("high")
    ! finalSpinFunctions(:, 2) = chi_{S - 1/2, S - 1/2} ("low")

    allocate(tmpSpinFunctionA(numberOfPrimitives))

    tmpSpinFunctionA = real(spinFunctionsArray(:, 1))
    norm1 = spinFunctionsScalarProductReal(tmpSpinFunctionA, tmpSpinFunctionA, numberOfPrimitives)
    finalSpinFunctions(:, 1) = tmpSpinFunctionA / sqrt(norm1)
    

    if (numberOfSpinFunctions == 2) then
      tmpSpinFunctionA = real(spinFunctionsArray(:, 2))
      norm1 = spinFunctionsScalarProductReal(tmpSpinFunctionA, tmpSpinFunctionA, numberOfPrimitives)
      tmpSpinFunctionA = real(spinFunctionsArray(:, 3))
      norm2 = spinFunctionsScalarProductReal(tmpSpinFunctionA, tmpSpinFunctionA, numberOfPrimitives)

      finalSpinFunctions(:, 2) = simpleClebsch(SeDoubled, 1, SeDoubled - 1, -1) * real(spinFunctionsArray(:, 2)) / sqrt(norm1) + &
      simpleClebsch(SeDoubled, 1, SeDoubled - 1, 1) * real(spinFunctionsArray(:, 3)) / sqrt(norm2)

      tmpSpinFunctionA = finalSpinFunctions(:, 2)

      ! call showSpinFunctionReal(tmpSpinFunctionA, primitives, n, numberOfPrimitives, spinFunctionString)
      ! write(*, '(a)') trim(adjustl(spinFunctionString))
      ! print *, '====================================='

    endif

    ! we want to calculate some mean values with our spin function(s)
    ! note that for any operator O commuting with all P_{a} from the group S_{n electrons}
    ! <O> = <chi phi | O | A^{el}[chi phi]> = <chi phi | O | sum_{a} parity(P_{a}) P_{a} chi phi>

    ! usually for the operators we need spin and spatial parts can be factorized
    ! in a following way:
    ! <O> = sum_{a} parity(P_{a}) <chi | O^s | P^s_{a} chi> <phi | O^s | P^r_{a} phi>



    ! so, we store the following:
    ! 1. spin function(s) as string

    ! 2. <S^2> = - n (n - 4) / 4 + <sum_{i < j} P_{ij}> (note that we store S, not S (S + 1))
    ! (needed as test)

    ! 3. <chi | 1 | P^s_{a} chi> for all P^s_{a} from the group S_{n electrons}
    ! (needed as coeffs for spin-free operators)

    ! 4. <chi | s_i s_j | P^s_{a} chi> = - 1 / 4 + 1 / 2 <P^s_{ij} P_{a}> for all P^s_{a} from the group S_{n electrons}
    ! (needed as coeffs for SSF operator)

    ! 5. <chi |s_z_i | P^s_{a} chi> for all P^s_{a} from the group S_{n electrons}
    ! (needed as coeffs for SO and AMM operators)

    ! define P^s_{ij} first
    allocate(pairPermutations(n, n, n, n))
    pairPermutations = 0
    do i = 1, n
      do j = 1, n
        do k = 1, n
          pairPermutations(k, k, i, j) = 1
        enddo
      enddo
    enddo

    do i = 1, n
      do j = i + 1, n

        pairPermutations(i, i, i, j) = 0
        pairPermutations(j, j, i, j) = 0
        pairPermutations(j, i, i, j) = 1
        pairPermutations(i, j, i, j) = 1

        pairPermutations(i, i, j, i) = 0
        pairPermutations(j, j, j, i) = 0
        pairPermutations(j, i, j, i) = 1
        pairPermutations(i, j, j, i) = 1
      enddo
    enddo


    allocate(tmpSpinFunctionB(numberOfPrimitives))
    allocate(tmpSpinFunctionC(numberOfPrimitives))

    if (Glob_ProcID == 0) then
      open(newunit=io, file="spinData.txt", status="replace", action="write")
      write(io, '("Se from Young string =" , 1x, f6.3)') real(SeDoubled) * 0.5
      close(io)
    endif

    spinFreeME = ZERO
    SiSjME = ZERO



    do p = 1, numberOfSpinFunctions

      tmpSpinFunctionA = finalSpinFunctions(:, p)

      if (p > 1) then
        call showSpinFunctionReal(tmpSpinFunctionA, primitives, n, numberOfPrimitives, spinFunctionString)
      else
        call showSpinFunction(spinFunctionsArray(:, 1), primitives, n, numberOfPrimitives, spinFunctionString)
      endif

      k = n
      test = - dble(k * (k - 4)) / FOUR
      do i = 1, n
        do j = i + 1, n

          call permuteSpinFunctionReal(primitives, tmpSpinFunctionA, tmpSpinFunctionB, &
          pairPermutations(:, :, i, j), n, numberOfPrimitives)

          ! call showSpinFunctionReal(tmpSpinFunctionB, primitives, n, numberOfPrimitives, spinFunctionString)
          ! write(*, '(a)') trim(adjustl(spinFunctionString))

          test = test + spinFunctionsScalarProductReal(tmpSpinFunctionA, tmpSpinFunctionB, numberOfPrimitives)

        enddo
      enddo

      test = (sqrt(FOUR * test + ONE) - ONE) * ONEHALF
      
      if (Glob_ProcID == 0) then

        open(newunit=io, file="spinData.txt", status="old", action="write", position = "append")
        write(io, '(a)') '==========================================='
        write(io, '(a, a)') "chi = ", trim(adjustl(spinFunctionString))      
        write(io, '("S calculated         =" , 1x, f6.3)') test
        close(io)

      endif

      do ptr = 1, nFactorial

        call permuteSpinFunctionReal(primitives, tmpSpinFunctionA, tmpSpinFunctionB, &
        permutationMatrices(:, :, ptr), n, numberOfPrimitives)

        !call showSpinFunction(spinFunction, primitives, n, Cnk, spinFunctionString)
        !write(*, '(a)') trim(adjustl(spinFunctionString))

        spinFreeME(ptr) = spinFunctionsScalarProductReal(tmpSpinFunctionA, tmpSpinFunctionB, numberOfPrimitives)

      enddo ! all permutations


      ! <(- 1 / 4 + 1 / 2 P^s_{ij}) P_{a}>
      

      do ptr = 1, nFactorial

        call permuteSpinFunctionReal(primitives, tmpSpinFunctionA, tmpSpinFunctionB, &
        permutationMatrices(:, :, ptr), n, numberOfPrimitives)

        do i = 1, n
          do j = i + 1, n

            call permuteSpinFunctionReal(primitives, tmpSpinFunctionB, tmpSpinFunctionC, &
            pairPermutations(:, :, i, j), n, numberOfPrimitives)

            SiSjME(i, j, p, ptr) = -ONEFOURTH * &
            spinFunctionsScalarProductReal(tmpSpinFunctionA, tmpSpinFunctionB, numberOfPrimitives) + &
            ONEHALF * spinFunctionsScalarProductReal(tmpSpinFunctionA, tmpSpinFunctionC, numberOfPrimitives)


          enddo
        enddo

      enddo


      ! ! for test purposes one can store some mean values
      ! if (Glob_ProcID == 0) then

      !   open(newunit=io, file="spinData.txt", status="old", action="write", position = "append")
        
      !   ! spin free
      !   write(io, '("<chi | 1 | P^s_{a} chi>:")')
      !   do ptr = 1, nFactorial
      !     if (positronPosition > 0) then
      !       if (permutationMatrices(positronPosition, positronPosition, ptr) /= 1) cycle
      !     endif

      !     write(io, '(i3, 2x, f6.3)') ptr, spinFreeME(ptr)
      !   enddo

      !   ! ! S_z(i)      
      !   ! write(io, '("<chi |s_z_i | P^s_{a} chi>:")')
      !   ! do ptr = 1, nFactorial
      !   !   if (positronPosition > 0) then
      !   !     if (permutationMatrices(positronPosition, positronPosition, ptr) /= 1) cycle
      !   !   endif

      !   ! ! s(i) s(j) for each pair
      !   ! write(io, '("<chi | s_i s_j | P^s_{a} chi>:")')
      !   ! do ptr = 1, nFactorial
      !   !   if (positronPosition > 0) then
      !   !     if (permutationMatrices(positronPosition, positronPosition, ptr) /= 1) cycle
      !   !   endif

      !   !   do i = 1, n
      !   !     do j = i + 1, n
      !   !       write(io, '(i3, 2x, i1, 2x, i1, 2x, f6.3)') ptr, i, j, SiSjME(i, j, p, ptr)
      !   !     enddo
      !   !   enddo
      !   ! enddo
        
      !   close(io)

      ! endif

    enddo ! number of spin functions




  end subroutine

  subroutine permute(p, x, y, n)
    implicit none

    ! simple permutation of a primitive by a matrix

    integer, intent(in) :: n
    integer, dimension(n), intent(in) :: x
    integer, dimension(n, n), intent(in) :: p

    integer, dimension(n), intent(out) :: y ! px

    integer :: i, j

    y = 0
    do i = 1, n
      do j = 1, n
        y(i) = y(i) + p(i, j) * x(j)
      enddo
    enddo

  end subroutine

  subroutine actOnSpinFunctionWithSzi(primitives, spinFunction, i, n, numberOfPrimitives)
    implicit none

    ! returns 2 s_z(i) \Chi from i and \Chi
    ! i is the particle's number

    ! 2 s_z(i) (.....a.....) = (.....a.....)
    ! 2 s_z(i) (.....b.....) = -(.....b.....)
    !                ^i'th place

    integer, intent(in) :: n, numberOfPrimitives, i
    real(kind = dprec), dimension(numberOfPrimitives), intent(inout) :: spinFunction ! old coefficients
    integer, dimension(n, numberOfPrimitives), intent(in) :: primitives ! all the strings possible

    ! local variables
    integer :: j

    do j = 1, numberOfPrimitives
      if (abs(spinFunction(j)) < localEps) cycle
      if (primitives(i, j) == 0 ) spinFunction(j) = - spinFunction(j)
    enddo

  end subroutine

  subroutine actOnSpinFunctionWithSMinusi(primitives, spinFunction, i, n, numberOfPrimitives)
    implicit none

    ! returns S_{-}(i) \Chi from i and \Chi
    ! i is the particle's number

    ! S_{-}(i) (.....a.....) = (.....b.....)
    ! S_{-}(i) (.....b.....) = 0
    !                ^i'th place

    integer, intent(in) :: n, numberOfPrimitives, i
    integer, dimension(numberOfPrimitives), intent(inout) :: spinFunction ! old coefficients
    integer, dimension(n, numberOfPrimitives), intent(in) :: primitives ! all the strings possible

    ! local variables
    integer :: j, found, l, k, s
    integer, dimension(n) :: primitiveA
    integer, dimension(numberOfPrimitives) :: newSpinFunction

    newSpinFunction = 0

    do j = 1, numberOfPrimitives
      if (spinFunction(j) == 0) cycle
      
      if (primitives(i, j) == 1) then
        primitiveA = primitives(:, j)
        primitiveA(i) = 0
        
        ! now we are looking for the string in our "library"

        found = 0
        do l = 1, numberOfPrimitives
          if (found > 0) exit

          do k = 1, n
            if (primitiveA(k) /= primitives(k, l)) exit ! strings are different
            if (k == n) found = l ! found the right string
          enddo

        enddo

        if (found <= 0) stop "cant act with S-"

        newSpinFunction(found) = newSpinFunction(found) + spinFunction(j)

      endif

    enddo

    call beautifySpinFunction(newSpinFunction, numberOfPrimitives)
    spinFunction = newSpinFunction

  end subroutine

  function intPairGcd(a, b) result(gcd)
    implicit none

    ! iterative (non-recursive) naive determination of the gcd of a and b

    integer, intent(in) :: a, b
    integer :: gcd

    ! local copies
    integer :: la, lb

    la = a
    lb = b

    do while (la > 0 .and. lb > 0)
      if (la > lb) then
        la = mod(la, lb)
      else 
        lb = mod(lb, la)
      endif
    enddo

    if (la == 0) then
      gcd = lb
      return
    else
      gcd = la
      return
    endif


  end function

  subroutine beautifySpinFunction(spinFunction, numberOfPrimitives)
    implicit none

    ! returns spin function integer coefficients 
    ! divided by their GCD
    ! it is only needed for a pretty resulting string

    integer, intent(in) :: numberOfPrimitives
    integer, dimension(numberOfPrimitives), intent(inout) :: spinFunction ! old coefficients

    ! local variables:
    integer :: gcd

    integer :: l

    ! first non-zero element is our gcd guess

    do l = 1, numberOfPrimitives
      if (spinFunction(l) == 0) cycle
      
      gcd = abs(spinFunction(l))
      exit
    enddo

    do l = 1, numberOfPrimitives
      if (spinFunction(l) == 0) cycle
      
      gcd = intPairGcd(abs(spinFunction(l)), gcd)

      if (gcd == 1) then
        exit
      endif
    enddo

    do l = 1, numberOfPrimitives
      if (spinFunction(l) == 0) cycle

      spinFunction(l) = spinFunction(l) / gcd
    enddo

  end subroutine

  subroutine generateSpinYoungFromSpatialString(spatialYoung, n, nFactorial, NumYTerms, YCoeff, YMatr)
    implicit none

    ! takes spatial Young operator as an input and
    ! generates the corresponding spin Young operator

    integer, intent(in) :: n, nFactorial
    character(len = maxLen), intent(in) :: spatialYoung
    integer, intent(out) :: NumYTerms
    ! we assume that the string was already cleaned and checked before
    integer, dimension(nFactorial), intent(out) :: YCoeff
    integer, dimension(n, n, nFactorial), intent(out) :: YMatr

    ! local variables
    integer :: strLen, i, R, FirstLPos, LastRPos, j, NumFactY, k
    integer :: p, q, TotNumOfYTerms, CurrNumOfTerms
    character(len = 1) :: c1
    character(len = maxLen), dimension(:), allocatable :: YOpStr, TempYOpStr
    integer, dimension(:), allocatable :: NumTermsInYOpFact, TempSymCoeff, TempSymCoeff1

    integer, dimension(:, :), allocatable :: Matr1, Matr2, Matr3, Matr4
    integer, dimension(:, :, :), allocatable :: TempSymMatr, TempSymMatr1
    integer, dimension(:, :, :, :), allocatable :: pairPermutations

    integer :: Coeff, Cf3, ii, jj, w, kk, s, t

    character (len = maxLen) :: myFmt

    strLen = len_trim(spatialYoung)

    ! the following is just copy-paste of the corresponding code in workproc.f90

    ! counting how many brackets there are
    R = 0
    do i = 1, strLen
      if (spatialYoung(i:i) == ')') R = R + 1
    enddo

    !NumFactY is the number of factors in the Young operator,
    !FirstLPos is the position of the first left bracket,
    !LastRPos is the position of the last right bracket,
    if (R /= 0) then
      FirstLPos = scan(spatialYoung(1 : StrLen), '(')
      LastRPos = scan(spatialYoung(1 : StrLen), ')', back = .true.)
      NumFactY = R
      i = 0
      do j = 1, R
        k = 0
        i = i + 1
          c1 = spatialYoung(i:i)
          do while (c1 /= '(')
          if (c1 /= '*') k = 1
          i = i + 1
          c1 = spatialYoung(i:i)
        enddo
        if (k == 1) NumFactY = NumFactY + 1
        do while (c1 /= ')')
          i = i + 1
          c1 = spatialYoung(i:i)
        enddo
      enddo
      if (spatialYoung(StrLen:StrLen) /= ')') NumFactY = NumFactY + 1
    else
      NumFactY = 1
    endif

    !Splitting spatialYoung into an array of smaller
    !strings, YOpStr. Each column of this array will contain just
    !one factor, with no brackets. A '+' or a '-' sign is added in
    !front of the first term in a factor if needed. Multiplication
    !signs are dropped .
    allocate(YOpStr(NumFactY))
    do i = 1, NumFactY
      YOpStr(i) = ' '
    enddo
    if (R == 0) then
      c1 = spatialYoung(1:1)
      if ((c1 /= '+').or.(c1 /= '-')) then
        YOpStr(1)(1:1) = '+'
        YOpStr(1)(2:StrLen + 1) = spatialYoung(1:StrLen)
      else
        YOpStr(1)(1:StrLen) = spatialYoung(1:StrLen)
      endif
    else
      i = 1
      k = 1
      p = i
      q = 0
      c1 = spatialYoung(i:i)
      if ((c1 /= '(').and.(c1 /= '+').and.(c1 /= '-')) then
        q = 1
        YOpStr(k)(1:1) = '+'
      endif
      do while (spatialYoung(i:i) /= '(')
        i = i + 1
      enddo
      if (i > 1) then
        YOpStr(k)(p + q:i - 1 + q) = spatialYoung(p:i - 1)
        k = k + 1
      endif
      do j = 1, R
        i = i + 1
        p = i
        q = 0
        c1 = spatialYoung(i:i)
        if ((c1 /= ')').and.(c1 /= '+').and.(c1 /= '-')) then
          q = 1
          YOpStr(k)(1:1) = '+'
        endif
        do while (spatialYoung(i:i) /= ')')
          i = i + 1
        enddo
        YOpStr(k)(1 + q:i + q - p) = spatialYoung(p:i - 1)
        k = k + 1
        i = i + 1
        c1 = spatialYoung(i:i)
        if (c1 == '*') then
          i = i + 1
          c1 = spatialYoung(i:i)
        endif
        if ((c1 /= '(').and.(c1 /= ' '))  then
          p = i
          YOpStr(k)(1:1) = '+'
          do while ((c1 /= '(').and.(c1 /= ' '))
            i = i + 1
            c1 = spatialYoung(i:i)
          enddo
          YOpStr(k)(2:i + 1 - p) = spatialYoung(p:i - 1)
          k = k + 1
        endif
       enddo
    endif

    ! print *, '.'
    ! !Print all factors in the Young operator
    ! j = StrLen + 1
    ! do i = 1, NumFactY
    !   write (*, '(1x,i3,1x,a3,a)') i, ':  ', YOpStr(i)(1:j)
    ! enddo

    ! the end of the copied part

    ! now we transpose the Young table : the one for spin variables
    ! is the spatial one transposed
    ! it corresponds to exchanging S and A operators
    ! note that in some inout files user defines AS (not SA) as a spatial Young operator
    ! it can be shown that (SA)_{table 1} = (AS)_{table 2} if the tables
    ! 1 and 2 correspond to the same mean value of S^2 operator
    ! (transition between tables of the same shape is a simple renaming of particles)


    ! we check the 1st factor in Young operator
    j = 0
    ! if it doesn't contain any minus signs, it is part of a S operator
    do i = 1, maxLen
      if (YOpStr(1)(i:i) == 'P') then ! check the sign before it
        if (YOpStr(1)(i - 1 : i - 1) == '-') j = -1 ! Y = AS
      endif
    enddo

    ! if we found no minuses, either it is part of S operator,
    !  or we have 1 column (S has maximal possible value)
    if (j == 0) then
      do i = 1, maxLen
        if (YOpStr(1)(i:i) == 'P') then ! check the sign before it
          if (YOpStr(1)(i - 1 : i - 1) == '+') j = 1 ! Y = SA
          exit
        endif
      enddo
    endif

    ! now j = 1  <=> Y = SA
    !     j = 0  <=> 1 column Young table
    !     j = -1 <=> Y = AS

    allocate(TempYOpStr(NumFactY))

    p = NumFactY + 1
    ! transposing Young table
    do k = 1, NumFactY
      do i = 2, maxLen
        if (j == 1) then ! SA
          if (YOpStr(k)(i - 1:i) == '-P') p = k ! found the first A operator
        else if (j == -1) then ! AS
          if (YOpStr(k)(i - 1:i) == '+P') p = k ! found the first S operator
        endif
      enddo
      if (p < NumFactY + 1) exit
    enddo


    q = 1
    do k = p, NumFactY
      TempYOpStr(q) = YOpStr(k)
      q = q + 1
    enddo
    do k = 1, p - 1
      TempYOpStr(q) = YOpStr(k)
      q = q + 1
    enddo

    ! now we change every '+P' to '-P' and vice versa
    YOpStr = TempYOpStr

    do k = 1, NumFactY
      do i = 2, maxLen
        if (TempYOpStr(k)(i - 1:i) == '-P') then
          YOpStr(k)(i - 1:i) = '+P'
        endif
        if (TempYOpStr(k)(i - 1:i) == '+P') then
          YOpStr(k)(i - 1:i) = '-P'
        endif
      enddo
    enddo


    ! !Print all factors in the Young operator
    ! j = StrLen + 1
    ! do i = 1, NumFactY
    !   write (*, '(1x,i3,1x,a3,a)') i, ':  ', YOpStr(i)(1:j)
    ! enddo

    ! now we again copy some code from workproc.f90

    !Counting how many terms there are in each factor of the Young
    !operator, as well as the total number of terms in the nonsimplified
    !Young operator
    allocate(NumTermsInYOpFact(NumFactY))
    TotNumOfYTerms = 1
    do k = 1, NumFactY
      j = 0
      do i = 1, maxLen
        if ((YOpStr(k)(i:i) == '+').or.(YOpStr(k)(i:i) == '-')) j = j + 1
      enddo
      NumTermsInYOpFact(k) = j
      TotNumOfYTerms = TotNumOfYTerms * j
    enddo

    allocate(Matr1(1:n, 1:n))
    allocate(Matr2(1:n, 1:n))
    allocate(Matr3(1:n, 1:n))
    allocate(Matr4(1:n, 1:n))

    ! !Multiplying all factors in YOpStr and placing actual matrices
    ! !and coefficients in arrays YMatr and YCoeff
    !One should remember one important fact here: a product of
    !of actual pair permutation operators corresponds to the reversed
    !product of matrices that act on the vector of 'a's and 'b's.
    !Thus, when doing multiplication we will simultaneously be changing
    !the order of permutation matrices.

    ! generate pair permutation matrices

    allocate(pairPermutations(n, n, n, n))
    !First set all of them to be unit matrices
    pairPermutations = 0
    do i = 1, n
      do j = 1, n
        do k = 1, n
          pairPermutations(k, k, i, j) = 1
        enddo
      enddo
    enddo

    do i = 1, n
      do j = i + 1, n

        pairPermutations(i, i, i, j) = 0
        pairPermutations(j, j, i, j) = 0
        pairPermutations(j, i, i, j) = 1
        pairPermutations(i, j, i, j) = 1

        pairPermutations(i, i, j, i) = 0
        pairPermutations(j, j, j, i) = 0
        pairPermutations(j, i, j, i) = 1
        pairPermutations(i, j, j, i) = 1
      enddo
    enddo



    CurrNumOfTerms=NumTermsInYOpFact(NumFactY)
    allocate(TempSymCoeff(CurrNumOfTerms))
    allocate(TempSymMatr(n,n,CurrNumOfTerms))
    do j=NumFactY,1,-1
      !reading the current factor
      k=0
      i=1
      c1=YOpStr(j)(i:i)
      p=i
      do while (c1/=' ')
        i=i+1
        c1=YOpStr(j)(i:i)
        do while ((c1/='P').and.(c1/='+').and.(c1/='-').and.(i<maxLen))
          i=i+1
          c1=YOpStr(j)(i:i)
        enddo
        if (i-p>1) then
          read(YOpStr(j)(p:i-1),*) Coeff
        else
          if (YOpStr(j)(i-1:i-1)=='+') then
            Coeff=1
    	  else
            Coeff=-1
    	  endif
        endif
        Matr1=pairPermutations(1:n,1:n,1,1)
        do while (c1=='P')
          read(YOpStr(j)(i+1:i+1),*) p
          read(YOpStr(j)(i+2:i+2),*) q
    	  Matr2(1:n,1:n)=pairPermutations(1:n,1:n,p,q)
    	  Matr4(1:n,1:n)=Matr1(1:n,1:n)
    	  do ii=1,n
    	    do jj=1,n
    	      w=0
    	      do kk=1,n
    	        w=w+Matr2(ii,kk)*Matr4(kk,jj)
    	      enddo
    	      Matr1(ii,jj)=w
    	    enddo
    	  enddo
    	  i=i+3
          c1=YOpStr(j)(i:i)
        enddo
        k=k+1
        p=i
        if (j/=NumFactY) then
          if (k==1) then
    	    Matr3(1:n,1:n)=Matr1(1:n,1:n)
            Cf3=Coeff
    	  else
    	    do s=1,t
              Matr2(1:n,1:n)=TempSymMatr(1:n,1:n,s)
              q=t*(k-1)+s
    	      do ii=1,n
    	        do jj=1,n
    	          w=0
    	          do kk=1,n
    	            w=w+Matr2(ii,kk)*Matr1(kk,jj)
    	          enddo
    	          TempSymMatr(ii,jj,q)=w
    	        enddo
    	      enddo
    	      TempSymCoeff(q)=Coeff*TempSymCoeff(s)
    	    enddo
          endif
    	else
          TempSymMatr(1:n,1:n,k)=Matr1(1:n,1:n)
          TempSymCoeff(k)=Coeff
        endif
      enddo
      if (j/=NumFactY) then
        do s=1,t
          Matr2(1:n,1:n)=TempSymMatr(1:n,1:n,s)
    	  do ii=1,n
    	     do jj=1,n
    	        w=0
    	        do kk=1,n
    	          w=w+Matr2(ii,kk)*Matr3(kk,jj)
    	        enddo
    	        TempSymMatr(ii,jj,s)=w
    	     enddo
    	  enddo
    	  TempSymCoeff(s)=Cf3*TempSymCoeff(s)
        enddo
      endif
      !mark the identical terms (adding their coefficients
      !and setting all of them but one to zero)
      t=CurrNumOfTerms
      do i=1,CurrNumOfTerms
        if (TempSymCoeff(i)==0) cycle
        do s=i+1,CurrNumOfTerms
          if (TempSymCoeff(s)==0) cycle
          if (all(TempSymMatr(1:n,1:n,i)==TempSymMatr(1:n,1:n,s))) then
            TempSymCoeff(i)=TempSymCoeff(i)+TempSymCoeff(s)
            if (TempSymCoeff(i)==0) t=t-1
    	    TempSymCoeff(s)=0
    	    t=t-1
    	  endif
        enddo
      enddo
      !reallocate arrays containing symmetry terms
      !to allow for multiplication by the next factor
      if (j/=1) then
        allocate(TempSymCoeff1(t))
        allocate(TempSymMatr1(n,n,t))
        s=0
        do i=1,CurrNumOfTerms
          if (TempSymCoeff(i)/=0) then
            s=s+1
            TempSymCoeff1(s)=TempSymCoeff(i)
            TempSymMatr1(1:n,1:n,s)=TempSymMatr(1:n,1:n,i)
          endif
        enddo
        CurrNumOfTerms=t*NumTermsInYOpFact(j-1)
        deallocate(TempSymCoeff)
        deallocate(TempSymMatr)
        allocate(TempSymCoeff(CurrNumOfTerms))
        allocate(TempSymMatr(n,n,CurrNumOfTerms))
        TempSymCoeff(1:t)=TempSymCoeff1(1:t)
        TempSymMatr(1:n,1:n,1:t)=TempSymMatr1(1:n,1:n,1:t)
        deallocate(TempSymCoeff1)
        deallocate(TempSymMatr1)
      endif
    enddo

    NumYTerms=t
    !allocate(YCoeff(NumYTerms))
    !allocate(YMatr(n,n,NumYTerms))
    YCoeff = 0
    YMatr = 0

    s=0
    do i=1,CurrNumOfTerms
      if (TempSymCoeff(i)/=0) then
        s=s+1
        YCoeff(s)=TempSymCoeff(i)
        YMatr(1:n,1:n,s)=TempSymMatr(1:n,1:n,i)
      endif
    enddo
    deallocate(TempSymCoeff)
    deallocate(TempSymMatr)

    ! the end of a copied part

    ! now transpose every matrix, since the code above
    ! generates the matrices P^(-1)
    ! Li example:
    ! consider the primitive aba
    ! P13 P12 (aba) = aab (position in a string is a particle number)
    ! P (aba) = aab with
    ! P = P13 * P12 = (001 / 100 / 010)
    ! for spatial function P13 P12 f(x1, x2, x3) = f (x2, x3, x1)
    ! it is convinient to act on the coordinate vector
    ! P (x1, x2, x3) = (x2, x3, x1) with
    ! P = (010 / 001 / 100)
    ! then for the same particle permutation
    ! P_{spin} = P_{spatial}'

    do t = 1, NumYTerms

      do i = 1, n
        do j = i + 1, n
          s = YMatr(i, j, t)
          YMatr(i, j, t) = YMatr(j, i, t)
          YMatr(j, i, t) = s
        enddo
      enddo
    enddo

    ! write(myFmt, '("(", i0, "(i3))")') n
    ! do s = 1, NumYTerms
    !   print *, YCoeff(s)
    !   do i = 1, n
    !     write(*, myFmt) (YMatr(i, j, s), j = 1, n)
    !   enddo
    !   print *, '================='
    ! enddo

  end subroutine


  subroutine showSpinFunction(spinFunction, primitives, n, numberOfPrimitives, outString)
    implicit none

    ! prints normalized spin function as a string of a's and b's
    ! given the primitives (strings like aaaabb) library
    ! and the coefficients
    ! output example for ^2Li:
    ! 1/sqrt(6) * (-aab-baa+2aba)

    integer, intent(in) :: n, numberOfPrimitives

    integer, dimension(numberOfPrimitives), intent(in) :: spinFunction ! coefficients
    integer, dimension(n, numberOfPrimitives), intent(in) :: primitives ! all the strings possible

    character(len = *), intent(out) :: outString

    ! local variables
    integer :: i, j, cntr, norm

    character(len = 255) :: finalString, primitiveString
    character(len = 10) :: intString

    ! first we obtain the norm of our spin function
    norm = 0
    do i = 1, numberOfPrimitives
      if (spinFunction(i) == 0) cycle
      norm = norm + spinFunction(i)**2
    enddo

    if (norm > 1) then
      write(intString , '(i6)') norm
      finalString = '1/sqrt(' // trim(adjustl(intString)) // ') * ('
    else
      finalString = ''
    endif

    cntr = 0
    do i = 1, numberOfPrimitives
      if (spinFunction(i) == 0) cycle
      cntr = cntr + 1
      primitiveString = ''
      intString = ''
      if ((spinFunction(i) > 0) .and. (cntr > 1)) then
        primitiveString = trim(adjustl(primitiveString)) // '+'
      endif
      if (spinFunction(i) /= 1) then
        if ((spinFunction(i) /= -1)) then
          write(intString , '(i3)') spinFunction(i)
        else
          write(intString , '(a1)')'-'
        endif
      endif

      primitiveString = trim(adjustl(primitiveString)) // trim(adjustl(intString))

      do j = 1, n
        if (primitives(j, i) == 0) then
          primitiveString = trim(adjustl(primitiveString)) // 'b'
        else
          primitiveString = trim(adjustl(primitiveString)) // 'a'
        endif
      enddo

      finalString = trim(adjustl(finalString)) // trim(adjustl(primitiveString))

    enddo

    if (norm > 1) then
      finalString = trim(adjustl(finalString)) // ')'
    endif


    !write(*, '(a)') trim(adjustl(finalString))
    write(outString, '(a)') trim(adjustl(finalString))

  end subroutine

  subroutine showSpinFunctionReal(spinFunction, primitives, n, numberOfPrimitives, outString)
    implicit none

    ! prints normalized spin function as a string of a's and b's
    ! given the primitives (strings like aaaabb) library
    ! and the coefficients
    ! output example for ^2Li:
    ! 1/sqrt(6) * (-aab-baa+2aba)

    integer, intent(in) :: n, numberOfPrimitives

    real(kind = dprec), dimension(numberOfPrimitives), intent(in) :: spinFunction ! coefficients
    integer, dimension(n, numberOfPrimitives), intent(in) :: primitives ! all the strings possible

    character(len = *), intent(out) :: outString

    ! local variables
    integer :: i, j, cntr

    character(len = 528) :: finalString, primitiveString
    character(len = 20) :: intString

    real(kind = dprec) :: norm

    ! first we obtain the norm of our spin function
    norm = 0
    do i = 1, numberOfPrimitives
      if (spinFunction(i) == 0) cycle
      norm = norm + spinFunction(i)**2
    enddo
    norm = sqrt(norm)

    if (norm - ONE > localEps) then
      write(intString , '(f8.4)') norm
      finalString = '1/' // trim(adjustl(intString)) // ' * ('
    else
      finalString = ''
    endif

    cntr = 0
    do i = 1, numberOfPrimitives
      if (abs(spinFunction(i)) < localEps) cycle
      cntr = cntr + 1
      primitiveString = ''
      intString = ''
      if ((spinFunction(i) > localEps) .and. (cntr > 1)) then
        primitiveString = trim(adjustl(primitiveString)) // '+'
      endif
      if (abs(spinFunction(i) - ONE) > localEps) then
        if (abs(spinFunction(i) + ONE) > localEps) then
          write(intString , '(f8.4)') spinFunction(i)
        else
          write(intString , '(a1)')'-'
        endif
      endif

      primitiveString = trim(adjustl(primitiveString)) // trim(adjustl(intString))

      do j = 1, n
        if (primitives(j, i) == 0) then
          primitiveString = trim(adjustl(primitiveString)) // 'b'
        else
          primitiveString = trim(adjustl(primitiveString)) // 'a'
        endif
      enddo

      finalString = trim(adjustl(finalString)) // trim(adjustl(primitiveString))

    enddo

    if (norm > 1) then
      finalString = trim(adjustl(finalString)) // ')'
    endif


    !write(*, '(a)') trim(adjustl(finalString))
    write(outString, '(a)') trim(adjustl(finalString))

  end subroutine


  subroutine permuteSpinFunction(primitives, oldSpinFunction, newSpinFunction, permutation, n, numberOfPrimitives)
    implicit none

    ! takes a spin function as an input and act on it with the permutation
    ! described by the input matrix "permutation"

    integer, intent(in) :: n, numberOfPrimitives

    integer, dimension(numberOfPrimitives), intent(in) :: oldSpinFunction ! old coefficients
    integer, dimension(n, numberOfPrimitives), intent(in) :: primitives ! all the strings possible
    integer, dimension(n, n), intent(in) :: permutation ! permutation matrix
    integer, dimension(numberOfPrimitives), intent(out) :: newSpinFunction

    ! local variables
    integer :: i, j, l, found
    integer, dimension(n) :: permutedString


    newSpinFunction = 0

    do i = 1, numberOfPrimitives
      if (oldSpinFunction(i) == 0) cycle ! nothing to permute

      permutedString = 0
      call permute(permutation, primitives(:, i), permutedString, n)

      ! now we are looking for the string in our "library"

      found = 0
      do l = 1, numberOfPrimitives
        if (found > 0) exit

        do j = 1, n
          if (permutedString(j) /= primitives(j, l)) exit ! strings are different
          if (j == n) found = l ! found the right string
        enddo

      enddo

      newSpinFunction(found) = newSpinFunction(found) + oldSpinFunction(i)
    enddo

  end subroutine

  subroutine permuteSpinFunctionReal(primitives, oldSpinFunction, newSpinFunction, permutation, n, numberOfPrimitives)
    implicit none

    ! takes a spin function as an input and act on it with the permutation
    ! described by the input matrix "permutation"

    integer, intent(in) :: n, numberOfPrimitives

    real(kind = dprec), dimension(numberOfPrimitives), intent(in) :: oldSpinFunction ! old coefficients
    integer, dimension(n, numberOfPrimitives), intent(in) :: primitives ! all the strings possible
    integer, dimension(n, n), intent(in) :: permutation ! permutation matrix
    real(kind = dprec), dimension(numberOfPrimitives), intent(out) :: newSpinFunction

    ! local variables
    integer :: i, j, l, found
    integer, dimension(n) :: permutedString


    newSpinFunction = ZERO

    do i = 1, numberOfPrimitives
      if (abs(oldSpinFunction(i)) < localEps) cycle ! nothing to permute

      permutedString = 0
      call permute(permutation, primitives(:, i), permutedString, n)

      ! now we are looking for the string in our "library"

      found = 0
      do l = 1, numberOfPrimitives
        if (found > 0) exit

        do j = 1, n
          if (permutedString(j) /= primitives(j, l)) exit ! strings are different
          if (j == n) found = l ! found the right string
        enddo

      enddo

      newSpinFunction(found) = newSpinFunction(found) + oldSpinFunction(i)
    enddo

  end subroutine


  function primitivesScalarProduct(x, y, n) result(ans)
    implicit none

    integer, intent(in) :: n
    integer, dimension(n), intent(in) :: x, y

    integer :: i

    integer :: ans ! x'y

    ans = 1

    do i = 1, n
      if (x(i) /= y(i)) then
        ans = 0
        return
      endif
    enddo

  end function


  function spinFunctionsScalarProduct(functionA, functionB, numberOfPrimitives) result(ans)
    implicit none
    ! all the primitives are unique, so <f|g> is an ordinary scalar product
    ! of numberOfPrimitives-dimensional integer vectors

    integer, intent(in) :: numberOfPrimitives
    integer, dimension(numberOfPrimitives), intent(in) :: functionA, functionB ! coefficients

    integer :: ans

    ! local variables
    integer :: i

    ans = 0
    do i = 1, numberOfPrimitives
      ans = ans + functionA(i) * functionB(i)
    enddo

  end function


  function spinFunctionsScalarProductReal(functionA, functionB, numberOfPrimitives) result(ans)
    implicit none
    ! all the primitives are unique, so <f|g> is an ordinary scalar product
    ! of numberOfPrimitives-dimensional integer vectors

    integer, intent(in) :: numberOfPrimitives
    real(kind = dprec), dimension(numberOfPrimitives), intent(in) :: functionA, functionB ! coefficients

    real(kind = dprec) :: ans

    ! local variables
    integer :: i

    ans = ZERO
    do i = 1, numberOfPrimitives
      ans = ans + functionA(i) * functionB(i)
    enddo

  end function


  subroutine generatePermutationMatrices(matrices, n, nFactorial, parities)
    implicit none

    integer, intent(in) :: n, nFactorial
    integer, dimension(n, n, nFactorial), intent(out) :: matrices
    integer, dimension(nFactorial), intent(out) :: parities


    ! local variables
    integer :: i, ptr, tmp, j
    integer, dimension(:, :), allocatable :: permutedStrings
    integer, dimension(n) :: indeces, elements
    character (len = maxLen) :: myFmt

    allocate(permutedStrings(n, nFactorial))
    ! first, we generate all the possible permutations
    ! for a given string '1 2 3 ... n'

    ! unitary permutation
    do i = 1, n
      permutedStrings(i, 1) = i
    enddo

    ptr = 2
    ! we generate the arrays with Heap's algotithm
    ! https://en.wikipedia.org/wiki/Heap's_algorithm

    elements = permutedStrings(:, 1)
    indeces = 1
    i = 2
    do while (i <= n)
      if (indeces(i) < i) then

        if (mod(i, 2) /= 0) then
          tmp = elements(1)
          elements(1) = elements(i)
          elements(i) = tmp
        else
          tmp = elements(indeces(i))
          elements(indeces(i)) = elements(i)
          elements(i) = tmp
        endif

        permutedStrings(:, ptr) = elements
        ptr = ptr + 1

        indeces(i) = indeces(i) + 1
        i = 2

      else

        indeces(i) = 1
        i = i + 1

      endif
    enddo

    ! now the matrices (note that coordinate permutation matrices can be
    ! obtained by transposing these)
    matrices = ZERO
    do ptr = 1, nFactorial
      do i = 1, n
        matrices(permutedStrings(i, ptr), i, ptr) = 1
      enddo
    enddo

    ! ! code to print every permutation matrix:
    ! write(myFmt, '("(", i0, "(i3))")') n
    ! do ptr = 1, nFactorial
    !   do i = 1, n
    !     write(*, myFmt) (matrices(i, j, ptr), j = 1, n)
    !   enddo
    !   print *, '================='
    ! enddo

    ! straiforward inefficient way of determining the permutations' parity
    ! n^2 for each permutation
    ! in principle, non-recursive Heap's algorithm naturally generates parities -1 1 -1 1 -1 1 ...

    do ptr = 1, nFactorial
      tmp = 0
      do i = 1, n
        do j = i + 1, n
          if (permutedStrings(i, ptr) > permutedStrings(j, ptr)) tmp = tmp + 1
        enddo
      enddo
      parities(ptr) = (-1)**tmp
    enddo

    ! ! code to print every permutation and its parity:
    !
    ! write(myFmt, '("(", i0, "(i3))")') n + 1
    ! do i = 1, nFactorial
    !   write(*, myFmt) parities(i), (permutedStrings(j, i), j = 1, n)
    ! enddo
    !

  end subroutine

  function simpleClebsch(SeDoubled, SpDoubled, SDoubled, mpDoubled) result(ans)
    implicit none

    ! returns Clebsch(Se, S - mp; Sp, mp; S, S)

    integer, intent(in) :: SeDoubled, SpDoubled, SDoubled, mpDoubled
    real(kind = dprec) :: ans

    ! instead of using ifs or select case we create
    ! a 4-dimensional array and tabulate the Clebsch values

    integer, parameter :: n = 4
    real(kind = dprec), dimension(0 : n, 0 : n, 0 : n, -n : n) :: table

    table = ZERO

    ! S = 0
    table(0, 0, 0, 0) = ONE
    table(1, 1, 0, -1) = ONE / sqrt(TWO)
    table(1, 1, 0, 1) = - ONE / sqrt(TWO)
    table(2, 2, 0, -2) = ONE / sqrt(THREE)
    table(2, 2, 0, 0) = -ONE / sqrt(THREE)
    table(2, 2, 0, 2) = ONE / sqrt(THREE)



    ! S = 1/2
    table(0, 1, 1, 1) = ONE
    table(1, 0, 1, 0) = ONE
    table(2, 1, 1, -1) = sqrt(TWO / THREE)
    table(2, 1, 1, 1) = - sqrt(ONE / THREE)
    table(1, 2, 1, 0) = ONE / sqrt(THREE)
    table(1, 2, 1, 2) = - sqrt(TWO / THREE)

    ! S = 1
    table(2, 0, 2, 0) = ONE
    table(0, 2, 2, 2) = ONE
    table(1, 1, 2, 1) = ONE
    table(2, 2, 2, 0) = ONE / sqrt(TWO)
    table(2, 2, 2, 2) = -ONE / sqrt(TWO)
    table(3, 1, 2, -1) = sqrt(THREE) / TWO
    table(3, 1, 2, 1) = -ONE / TWO

    ! S = 3/2
    table(2, 1, 3, 1) = ONE
    table(1, 2, 3, 2) = ONE
    table(3, 0, 3, 0) = ONE
    table(0, 3, 3, 3) = ONE

    ! S = 2
    table(2, 2, 4, 2) = ONE


    ans = table(SeDoubled, SpDoubled, SDoubled, mpDoubled)


  end function

end module
